#include "check_phfrag.h"
#include <linux/fs.h>
#include <linux/mman.h>
#include <linux/debugfs.h>
#include <linux/kobject.h>
#include <linux/sysfs.h>
#include <linux/kernel.h>
#include <linux/slab.h>
#include <linux/string.h>
#include <linux/stat.h>
#include <linux/namei.h>
#include <linux/path.h>
#include <linux/uaccess.h>
#include <linux/blkdev.h>
#include <uapi/linux/fs.h>
#include <linux/init.h>
#include <linux/mount.h>
#include <linux/namei.h>
#include <linux/sched.h>

void PHFRAG_INIT(struct nvmev * nvmev){
	printk("Hello phfrag\n");
}

void PHFRAG_EXIT(void){
	printk("Bye Phfrag\n");
}

static inline bool valid_ppa(struct conv_ftl *conv_ftl, struct ppa *ppa)
{
	struct ssdparams *spp = &conv_ftl->ssd->sp;
	int ch = ppa->g.ch;
	int lun = ppa->g.lun;
	int pl = ppa->g.pl;
	int blk = ppa->g.blk;
	int pg = ppa->g.pg;
	//int sec = ppa->g.sec;

	if (ch < 0 || ch >= spp->nchs)
		return false;
	if (lun < 0 || lun >= spp->luns_per_ch)
		return false;
	if (pl < 0 || pl >= spp->pls_per_lun)
		return false;
	if (blk < 0 || blk >= spp->blks_per_pl)
		return false;
	if (pg < 0 || pg >= spp->pgs_per_blk)
		return false;

	return true;
}

static inline bool mapped_ppa(struct ppa *ppa)
{
	return !(ppa->ppa == UNMAPPED_PPA);
}

static bool is_next_correct(struct conv_ftl *conv_ftl, struct ppa pre, struct ppa next){
	
	struct ssdparams *spp = &conv_ftl->ssd->sp;
	
	int predict_next_ch = pre.g.ch;
	int predict_next_die = pre.g.lun + 1;
		
	if(predict_next_die >= spp->luns_per_ch){
		predict_next_die = 0;
		predict_next_ch ++;
		
		if(predict_next_ch >= spp->nchs){
			predict_next_ch = 0;
		}
	}	

	

	if(next.g.ch == predict_next_ch && next.g.lun == predict_next_die)
		return 1;
	else if(pre.g.ch == next.g.ch && pre.g.lun == next.g.lun && pre.g.pl == next.g.pl && pre.g.blk == next.g.blk)
		return 1; 

	return 0;	
	
}

int phfrag_check(struct nvmev_dev * dev){
	struct nvmev_config *cfg = &dev->config;
	struct nvmev_ns *ns = dev->ns;
	struct conv_ftl *conv_ftls = (struct conv_ftl *)ns->ftls;
	struct conv_ftl *conv_ftl = &conv_ftls[0];

	struct ssdparams *spp = &conv_ftl->ssd->sp;

	uint64_t lba = cfg->input_lba;
	uint64_t nr_lba = cfg->lba_len;
	uint64_t start_lpn = lba / spp->secs_per_pg;
	uint64_t end_lpn = (lba + nr_lba -1) / spp->secs_per_pg;

	uint64_t lpn;
	uint32_t nr_parts = ns->nr_parts;
	uint32_t i;
	uint64_t count = 0;
	struct ppa prev_ppa;
	uint64_t total_ppa = 0;
/*
	if((end_lpn / nr_parts) >= spp->tt_pgs){
		NVMEV_ERROR("lpn passed FTL range in phfrag");		
		return 0;
	}		

	for(i=0; (i<nr_parts) &&(start_lpn <= end_lpn); i++, start_lpn++){
		uint64_t index = start_lpn % nr_parts;
		conv_ftl = &conv_ftls[index];
		
		prev_ppa = conv_ftl->maptbl[start_lpn / nr_parts];

		for(lpn = start_lpn; lpn <= end_lpn; lpn+=nr_parts){
			uint64_t local_lpn;
			struct ppa cur_ppa;

			local_lpn = lpn / nr_parts;
		
			cur_ppa = conv_ftl->maptbl[local_lpn];
		
			if(!mapped_ppa(&cur_ppa) || !valid_ppa(conv_ftl, &cur_ppa))
				continue;

			total_ppa+=1;
			if(!mapped_ppa(&prev_ppa) || !is_next_correct(conv_ftl,prev_ppa, cur_ppa))
			{
				count++;
			}

			prev_ppa = cur_ppa;	
	
		}
	}*/

	for(lpn = start_lpn; lpn <= end_lpn; lpn++){
		uint64_t local_lpn;
		struct ppa cur_ppa;
		
		conv_ftl = &conv_ftls[lpn % nr_parts];
		local_lpn = lpn / nr_parts;
		cur_ppa = conv_ftl->maptbl[local_lpn];
		
		if(!mapped_ppa(&cur_ppa) || !valid_ppa(conv_ftl, &cur_ppa))
			continue;

		total_ppa++;

		if(lpn!=start_lpn && (!mapped_ppa(&prev_ppa) || !is_next_correct(conv_ftl,prev_ppa, cur_ppa)))
		{
			count++;
		}
		
		prev_ppa = cur_ppa;
	}

	printk(KERN_INFO "start_lba : %llu, count : %llu, total ppa : %llu\n",start_lpn, count,total_ppa);
	cfg->count = count;
	
	return 1;	

}  
